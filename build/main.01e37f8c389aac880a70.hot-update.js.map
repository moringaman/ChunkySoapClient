{"version":3,"file":"main.01e37f8c389aac880a70.hot-update.js","sources":["webpack:///./src/helpers/api.js"],"sourcesContent":["// import { fn } from '.';\nconst promiseRetry = require('promise-retry')\n\nexport default {\n  /**\n   * ( uses fetch to make authorized api requests )\n   *\n   * @param {*} url\n   * @param {*} method\n   * @param {*} data\n   * @returns\n   */\n  async send(url, method, data, type = \"protected\") {\n    // const apiAddress = process.env.RAZZLE_API_URI \n    const apiAddress = process.env.NODE_ENV === 'production' ? process.env.RAZZLE_API_URI : \"http://localhost:1337\";\n    // fn.getApiAddress()\n    const token = await JSON.parse(sessionStorage.getItem(\"jwtToken\"));\n    // await fn.getTokenFromStorage('sessionToken')\n    console.log(\"TOKEN \", token);\n    const baseURL = `${apiAddress}`;\n    let myHeaders = new Headers();\n    myHeaders.append(\"Content-Type\", \"application/json\");\n    if (token !== \"\" && type !== \"public\") {\n      myHeaders.append(\"Authorization\", `Bearer ${token}`);\n    }\n\n    var raw = JSON.stringify(data);\n    console.log(\"raw data \", raw);\n    var requestOptions = {\n      method: method,\n      headers: myHeaders,\n      body: raw,\n      redirect: \"follow\",\n    };\n\n    \n    // return fetch(`${baseURL}${url}`, requestOptions)\n    //   .then((response) => {\n    //     console.log(\"fetch response \", response);\n    //     if(response.status === 200) return response.json();\n\n    //     if (retries > 0) {\n    //       return fetch(`${baseURL}${url}`, requestOptions, retries - 1)\n    //       console.log(\"error\", error)\n    //     }\n    //   })\n    //   .then((result) => {\n    //     console.log(\"reftch result \", result);\n    //     return result;\n    //   })\n    //   .catch(error => {\n    //     console.log(error)\n    //     if (retries > 0) {\n    //       retries - 1\n    //       return fetch(`${baseURL}${url}`, requestOptions)\n    //     }\n    //   }\n    //   );\n\n\n  /**\n   * (retryFetch returns fetch which recursively calls itself if the request fails)\n   *\n   * @param {*} url\n   * @param {*} options\n   * @param {integer} retries\n   * @returns fetch\n   */\n\n      const retryFetch = (url, options, retries = 4) => {\n        return fetch(url,  options)\n        .then(response => {\n          console.log('STATUS', response.status)\n          if(response.status === 200) return response.json()\n          if (retries > 0 ) {\n            console.log('retries ', retries)\n            return retryFetch(url, options, retries - 1)\n          } else {\n            throw new Error(response)\n          }\n        })\n        .catch(console.error)\n      } \n\n       return retryFetch(`${baseURL}${url}`, requestOptions)\n\n  },\n};\n\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAHA;AAAA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AASA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAvEA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0EA;AAnFA;;;;A","sourceRoot":""}